{"version":3,"sources":["rules/spaceAfterTypeColon.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;kBAMe,qCAAqB,UAAC,OAAD,EAAa;AAC7C,QAAM,SAAS,CAAC,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,QAAtB,CAAD,KAAqC,QAArC,CAD8B;;AAG7C,WAAO,UAAC,YAAD,EAAkB;AACrB,+BAAU,aAAa,MAAb,EAAqB,UAAC,cAAD,EAAoB;AAC/C,gBAAM,gBAAgB,iCAAiB,cAAjB,EAAiC,OAAjC,CAAhB,CADyC;AAE/C,gBAAM,iBAAiB,mBAAM,cAAN,EAAsB,gBAAtB,KAA2C,mBAAM,cAAN,EAAsB,qBAAtB,CAA3C,CAFwB;;AAI/C,gBAAI,cAAJ,EAAoB;AAChB,oBAAM,aAAa,eAAe,cAAf,CAA8B,KAA9B,GAAsC,eAAe,KAAf,GAAuB,CAA7D,CADH;;AAGhB,oBAAI,UAAU,aAAa,CAAb,EAAgB;AAC1B,4BAAQ,MAAR,CAAe,cAAf,EAA+B,kCAAkC,aAAlC,GAAkD,oCAAlD,CAA/B,CAD0B;iBAA9B,MAEO,IAAI,UAAU,eAAe,CAAf,EAAkB;AACnC,4BAAQ,MAAR,CAAe,cAAf,EAA+B,kCAAkC,aAAlC,GAAkD,oCAAlD,CAA/B,CADmC;iBAAhC,MAEA,IAAI,CAAC,MAAD,IAAW,aAAa,CAAb,EAAgB;AAClC,4BAAQ,MAAR,CAAe,cAAf,EAA+B,mCAAmC,aAAnC,GAAmD,oCAAnD,CAA/B,CADkC;iBAA/B;aAPX;SAJ2B,CAA/B,CADqB;;AAkBrB,YAAI,aAAa,UAAb,EAAyB;AACzB,gBAAM,aAAa,aAAa,UAAb,CAAwB,cAAxB,CAAuC,KAAvC,GAA+C,aAAa,UAAb,CAAwB,KAAxB,GAAgC,CAA/E,CADM;;AAGzB,gBAAI,UAAU,aAAa,CAAb,EAAgB;AAC1B,wBAAQ,MAAR,CAAe,YAAf,EAA6B,gDAA7B,EAD0B;aAA9B,MAEO,IAAI,UAAU,eAAe,CAAf,EAAkB;AACnC,wBAAQ,MAAR,CAAe,YAAf,EAA6B,gDAA7B,EADmC;aAAhC,MAEA,IAAI,CAAC,MAAD,IAAW,aAAa,CAAb,EAAgB;AAClC,wBAAQ,MAAR,CAAe,YAAf,EAA6B,iDAA7B,EADkC;aAA/B;SAPX;KAlBG,CAHsC;CAAb","file":"rules/spaceAfterTypeColon.js","sourcesContent":["import _ from 'lodash';\nimport {\n    getParameterName,\n    iterateFunctionNodes\n} from './../utilities';\n\nexport default iterateFunctionNodes((context) => {\n    const always = (context.options[0] || 'always') === 'always';\n\n    return (functionNode) => {\n        _.forEach(functionNode.params, (identifierNode) => {\n            const parameterName = getParameterName(identifierNode, context);\n            const typeAnnotation = _.get(identifierNode, 'typeAnnotation') || _.get(identifierNode, 'left.typeAnnotation');\n\n            if (typeAnnotation) {\n                const spaceAfter = typeAnnotation.typeAnnotation.start - typeAnnotation.start - 1;\n\n                if (always && spaceAfter > 1) {\n                    context.report(identifierNode, 'There must be 1 space after \"' + parameterName + '\" parameter type annotation colon.');\n                } else if (always && spaceAfter === 0) {\n                    context.report(identifierNode, 'There must be a space after \"' + parameterName + '\" parameter type annotation colon.');\n                } else if (!always && spaceAfter > 0) {\n                    context.report(identifierNode, 'There must be no space after \"' + parameterName + '\" parameter type annotation colon.');\n                }\n            }\n        });\n\n        if (functionNode.returnType) {\n            const spaceAfter = functionNode.returnType.typeAnnotation.start - functionNode.returnType.start - 1;\n\n            if (always && spaceAfter > 1) {\n                context.report(functionNode, 'There must be 1 space after return type colon.');\n            } else if (always && spaceAfter === 0) {\n                context.report(functionNode, 'There must be a space after return type colon.');\n            } else if (!always && spaceAfter > 0) {\n                context.report(functionNode, 'There must be no space after return type colon.');\n            }\n        }\n    };\n});\n"],"sourceRoot":"/source/"}