{"version":3,"sources":["rules/requireReturnType.js"],"names":[],"mappings":";;;;;;;;;;;;;;kBAKe,UAAC,OAAD,EAAa;AACxB,QAAM,gBAAgB,CAAC,mBAAM,OAAN,EAAe,+CAAf,CAAD,IAAoE,2BAAW,OAAX,CAApE,CADE;;AAGxB,QAAI,CAAC,aAAD,EAAgB;AAChB,eAAO,YAAM,EAAN,CADS;KAApB;;AAIA,QAAM,iBAAiB,CAAC,mBAAM,OAAN,EAAe,YAAf,KAAgC,QAAhC,CAAD,KAA+C,QAA/C,CAPC;AAQxB,QAAM,oBAAoB,CAAC,mBAAM,OAAN,EAAe,8BAAf,KAAkD,OAAlD,CAAD,KAAgE,QAAhE,CARF;;AAUxB,QAAM,cAAc,EAAd,CAVkB;;AAYxB,QAAM,mBAAmB,SAAnB,gBAAmB,CAAC,YAAD,EAAkB;AACvC,oBAAY,IAAZ,CAAiB;AACb,sCADa;SAAjB,EADuC;KAAlB,CAZD;;AAkBxB,QAAM,wBAAwB,SAAxB,qBAAwB,CAAC,UAAD,EAAgB;AAC1C,eAAO,WAAW,QAAX,KAAwB,IAAxB,IAAgC,WAAW,QAAX,CAAoB,IAApB,KAA6B,WAA7B,IAA4C,WAAW,QAAX,CAAoB,QAApB,KAAiC,MAAjC,CADzC;KAAhB,CAlBN;;AAsBxB,QAAM,qCAAqC,SAArC,kCAAqC,CAAC,UAAD,EAAgB;AACvD,YAAM,yCAAyC,mBAAM,UAAN,EAAkB,gDAAlB,MAAwE,WAAxE,IAAuF,mBAAM,UAAN,EAAkB,6CAAlB,MAAqE,uBAArE,CAD/E;AAEvD,YAAM,6BAA6B,mBAAM,UAAN,EAAkB,6CAAlB,MAAqE,oBAArE,CAFoB;;AAIvD,eAAO,0CAA0C,0BAA1C,CAJgD;KAAhB,CAtBnB;;AA6BxB,QAAM,mBAAmB,SAAnB,gBAAmB,CAAC,YAAD,EAAkB;AACvC,YAAM,aAAa,YAAY,GAAZ,EAAb,CADiC;;AAGvC,YAAI,iBAAiB,WAAW,YAAX,EAAyB;AAC1C,kBAAM,IAAI,KAAJ,CAAU,WAAV,CAAN,CAD0C;SAA9C;;AAIA,YAAM,4BAA4B,aAAa,UAAb,CAPK;AAQvC,YAAM,4BAA4B,CAAC,yBAAD,KAA+B,CAAC,WAAW,mBAAX,IAAkC,sBAAsB,WAAW,mBAAX,CAAzD,CAA/B,CARK;AASvC,YAAM,kCAAkC,mCAAmC,UAAnC,CAAlC,CATiC;;AAWvC,YAAI,6BAA6B,+BAA7B,IAAgE,CAAC,iBAAD,EAAoB;AACpF,oBAAQ,MAAR,CAAe,YAAf,EAA6B,0CAA7B,EADoF;SAAxF,MAEO,IAAI,6BAA6B,CAAC,+BAAD,IAAoC,iBAAjE,EAAoF;AAC3F,oBAAQ,MAAR,CAAe,YAAf,EAA6B,sCAA7B,EAD2F;SAAxF,MAEA,IAAI,CAAC,yBAAD,IAA8B,CAAC,+BAAD,EAAkC;AACvE,gBAAI,kBAAkB,CAAC,aAAa,UAAb,EAAyB;AAC5C,wBAAQ,MAAR,CAAe,YAAf,EAA6B,iCAA7B,EAD4C;aAAhD;SADG;KAfc,CA7BD;;AAmDxB,QAAM,gBAAgB,SAAhB,aAAgB,GAAM;AACxB,oBAAY,GAAZ,GADwB;KAAN,CAnDE;;AAuDxB,WAAO;AACH,iCAAyB,gBAAzB;AACA,wCAAgC,gBAAhC;AACA,0BAAkB,gBAAlB;AACA,iCAAyB,aAAzB;AACA,yBAAiB,gBAAjB;AACA,gCAAwB,aAAxB;AACA,6BAAqB,gBAArB;AACA,oCAA4B,gBAA5B;AACA,4BAAoB,gBAApB;AACA,mCAA2B,gBAA3B;AACA,yBAAiB,yBAAC,IAAD,EAAU;AACvB,wBAAY,YAAY,MAAZ,GAAqB,CAArB,CAAZ,CAAoC,mBAApC,GAA0D,IAA1D,CADuB;SAAV;KAXrB,CAvDwB;CAAb","file":"rules/requireReturnType.js","sourcesContent":["import _ from 'lodash';\nimport {\n    isFlowFile\n} from './../utilities';\n\nexport default (context) => {\n    const checkThisFile = !_.get(context, 'settings.flowtype.onlyFilesWithFlowAnnotation') || isFlowFile(context);\n\n    if (!checkThisFile) {\n        return () => {};\n    }\n\n    const annotateReturn = (_.get(context, 'options[0]') || 'always') === 'always';\n    const annotateUndefined = (_.get(context, 'options[1].annotateUndefined') || 'never') === 'always';\n\n    const targetNodes = [];\n\n    const registerFunction = (functionNode) => {\n        targetNodes.push({\n            functionNode\n        });\n    };\n\n    const isUndefinedReturnType = (returnNode) => {\n        return returnNode.argument === null || returnNode.argument.name === 'undefined' || returnNode.argument.operator === 'void';\n    };\n\n    const getIsReturnTypeAnnotationUndefined = (targetNode) => {\n        const isReturnTypeAnnotationLiteralUndefined = _.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'undefined' && _.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'GenericTypeAnnotation';\n        const isReturnTypeAnnotationVoid = _.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'VoidTypeAnnotation';\n\n        return isReturnTypeAnnotationLiteralUndefined || isReturnTypeAnnotationVoid;\n    };\n\n    const evaluateFunction = (functionNode) => {\n        const targetNode = targetNodes.pop();\n\n        if (functionNode !== targetNode.functionNode) {\n            throw new Error('Mismatch.');\n        }\n\n        const isArrowFunctionExpression = functionNode.expression;\n        const isFunctionReturnUndefined = !isArrowFunctionExpression && (!targetNode.returnStatementNode || isUndefinedReturnType(targetNode.returnStatementNode));\n        const isReturnTypeAnnotationUndefined = getIsReturnTypeAnnotationUndefined(targetNode);\n\n        if (isFunctionReturnUndefined && isReturnTypeAnnotationUndefined && !annotateUndefined) {\n            context.report(functionNode, 'Must not annotate undefined return type.');\n        } else if (isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined && annotateUndefined) {\n            context.report(functionNode, 'Must annotate undefined return type.');\n        } else if (!isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined) {\n            if (annotateReturn && !functionNode.returnType) {\n                context.report(functionNode, 'Missing return type annotation.');\n            }\n        }\n    };\n\n    const evaluateNoise = () => {\n        targetNodes.pop();\n    };\n\n    return {\n        ArrowFunctionExpression: registerFunction,\n        'ArrowFunctionExpression:exit': evaluateFunction,\n        ClassDeclaration: registerFunction,\n        'ClassDeclaration:exit': evaluateNoise,\n        ClassExpression: registerFunction,\n        'ClassExpression:exit': evaluateNoise,\n        FunctionDeclaration: registerFunction,\n        'FunctionDeclaration:exit': evaluateFunction,\n        FunctionExpression: registerFunction,\n        'FunctionExpression:exit': evaluateFunction,\n        ReturnStatement: (node) => {\n            targetNodes[targetNodes.length - 1].returnStatementNode = node;\n        }\n    };\n};\n"],"sourceRoot":"/source/"}